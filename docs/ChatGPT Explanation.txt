Skip to content
You said:
i have a matlab script which we used at the control engineering lab (the values are not yet finished, but the main flow is there). first, tell me if this script is creating a fractional order pi/pd/pid controller. secondly, explain very briefly how the script works (i dont really know these control methods, so don't go into much depth).
clear all
load sin_0185.mat

% Ts = 0.005;
% t = 0:Ts:(length(y_exp)-1)*Ts; t = t';

figure
plot(t,u_exp, 'k'); hold on;
plot(t,y_exp, 'r');
title('Sine response - frequency 0.185, amplitude 1V, offset 6.3V');
legend('Input', 'Ouput');
ylabel('Amplitude (degrees)'); xlabel('Time (seconds)');
freq = 0.185;
phm = 45/180*pi; %phase margin

pas = round(1/freq/Ts)-1;
figure
plot(y_exp);
peaks_loc = 7955:floor(pas/2):2.846e4;
y_peaks = y_exp(peaks_loc);
max = mean(y_peaks(1:2:end));
min = mean(y_peaks(2:2:end));
scale = (max-abs(min))/2;

%normalising the data
u_norm =u_exp - 6.3;
y_norm = y_exp-scale;
figure
plot(t, u_norm, 'k'); hold on;
plot(t, y_norm, 'b');

M =  max-scale;
Phi = freq*2*pi*(86.48665-87.03525);

% figure(2), plot(tout,U,'b'), hold on, plot(tout,Ybar_expe, 'r');
simtime = t(end);
omg_cut = 2*pi*freq;
sim('ident_sin_real');
figure
plot(t,Ybar_expe); hold on
plot(t,u_norm); hold on
plot(t,y_norm);
title('The output derivative in comparison to the input and output');
legend('Derivative','Input', 'Ouput');
ylabel('Amplitude (degrees)'); xlabel('Time (seconds)');

MB = 6.577;
PhiB = 2*pi*freq*(71.597213-74.3242533);
wt = omg_cut;
phase_deriv = MB/M*cos(PhiB-Phi);
%phase_deriv =  -0.933888437118822;
process_phase = Phi;

data1=[];data2=[];data3=[];
for miu=0.2:0.001:2
    % calcul (L'*K-L*K')/(L^2+K^2)
    z1=miu*wt^(-miu-1)*sin(pi*miu/2);
    z2=2*wt^(-miu)*cos(pi*miu/2);
    z3=wt^(-2*miu);

    % se calculeaza ki

    ki1= -((z1+z2*phase_deriv)+sqrt((z1+z2*phase_deriv)^2-4*z3*phase_deriv^2))/(2*z3*phase_deriv);
    ki2= -((z1+z2*phase_deriv)-sqrt((z1+z2*phase_deriv)^2-4*z3*phase_deriv^2))/(2*z3*phase_deriv);
    
    ki3= (tan(pi-phm+process_phase)*(wt^miu))/(sin(pi*miu/2)-(tan(pi-phm+process_phase)*cos(pi*miu/2)));
    data1 = [data1; [ki1]];
    data2 = [data2; [ki2]];
    data3 = [data3; [ki3]];

end

miu=0.2:0.001:2;
figure; plot(miu,data1,'r')
hold on,plot(miu,data3,'b'),title('ki1 vs ki3'),grid

figure; plot(miu,data2,'r')
hold on, plot(miu,data3,'b'),title('ki2 vs ki3'),grid


miu = 1.09; %0.8983;
ki = (tan(pi-phm+process_phase)*(wt^miu))/(sin(pi*miu/2)-(tan(pi-phm+process_phase)*cos(pi*miu/2)));

kp = (1/M)*(1/sqrt(1+2*ki*wt^(-miu)*cos(pi*miu/2)+(ki^2)*wt^(-2*miu)));

% ki = ki*10;
% kp = kp/10;
alfa1=1-miu;
alfa = miu;
s_alfa1=ora_foc_RdK(alfa1,2,0.01,100);

reg = minreal(kp+kp*ki*tf(1,[1,0])*s_alfa1);
% reg = minreal(kp+kp*ki/s_alfa1);
regd = minreal(c2d(reg, Ts*2, 'zoh'),1e-4);
zpk(regd)
[num,den]=tfdata(regd,'v');
%sim('vtol_closedloop')
figure
bode(reg); hold on
bode(regd); hold off
reccurenceRelFromNumDen(num,den)

% figure
% bode(reg); hold on
% regd = c2d(reg, 0.005, 'foh')
% bode(regd); hold off

tau = 0.8;
Hvtol = tf(22.24, [1,0.6934, 5.244], 'iodelay', tau);

figure
step(feedback(Hvtol*reg,1));
figure
step(feedback(reg,Hvtol));
ChatGPT said:

Got it â€” this looks like a control lab script for designing a fractional-order controller, and youâ€™re right that the values arenâ€™t fully polished yet, but the structure is clear.
1ï¸âƒ£ Is this a fractional PI / PD / PID controller?

Yes â€” this script designs a fractional-order PI controller (often written as PI^Î»).

More specifically:

    It is not PD (no derivative term of the error)

    It is not full PID (no D term)

    It is a fractional PI because:

        There is a proportional term kp

        There is an integral term of non-integer order Î¼ (called miu in the code)

        The integral operator is sâˆ’Î¼sâˆ’Î¼, not 1/s1/s

So the controller structure is essentially:
C(s)=kp(1+kisâˆ’Î¼)
C(s)=kpâ€‹(1+kiâ€‹sâˆ’Î¼)

Thatâ€™s exactly what makes it fractional-order.
2ï¸âƒ£ Very brief explanation of how the script works (high level)

Hereâ€™s the big picture, without going deep into theory:

    Load and plot experimental data

        Uses a sine input (u_exp) and measured output (y_exp)

        Plots them to see the systemâ€™s response

    Extract frequency-domain information

        Uses peaks of the sine response to estimate:

            Gain (M)

            Phase (Phi)

        This is a basic system identification from sine testing

    Estimate derivative behavior

        A Simulink model (ident_sin_real) is used to estimate output derivatives

        This helps determine how the system behaves around the chosen frequency

    Sweep the fractional order Î¼

        The loop miu = 0.2:0.001:2

        Computes possible integral gains (ki) for each Î¼

        Finds values that satisfy:

            Desired phase margin

            Measured system phase and gain

    Choose one Î¼ and compute controller gains

        You manually pick miu = 1.09

        Compute:

            ki â†’ fractional integral gain

            kp â†’ proportional gain

    Build the fractional controller

        ora_foc_RdK approximates the fractional operator sâˆ’Î¼sâˆ’Î¼

        Controller is assembled as:

        reg = kp + kp*ki*(1/s)*s_alfa1;

        Then discretized for digital implementation

    Test it on the plant

        Apply the controller to a model (Hvtol)

        Plot step responses of the closed loop

One-sentence summary

ğŸ‘‰ This script identifies a system using sine data, then designs and tests a fractional-order PI controller that meets a chosen phase margin at a specific frequency.

If you want, I can also:

    Rewrite this as a clean block diagram

    Explain what â€œfractional integralâ€ means intuitively

    Help you label this properly for a lab report

You said:
my final goal: i need to make a project where i control the RPM of a computer fan. i already have everything implemented in C#, so don't talk about that part, but the controller i used to control the RPM on the fan is a FOPID, which I did NOT compute, i just used some values for KP, KI, KD, and the other which i don't know which are the values that can be tweaked, some lambda and something else (github copilot made the code) (chosen using educated guesses). 

what i need now is to use this matlab script to compute a FOPI controller, i think. maybe even a FOPID, if it's not to complicated, but there are some problems:
- i know briefly control engineering
- i understand the idea and sort of how stuff works (from a mathematical pov, i know the mechanical and code parts of the C# code and the fan)
- i know that sometimes there is a need for PI ctrl, sometimes only PD will do the trick, but sometimes PID is the only one that works, but i don't know why and what each of P, I and D do exactly
- i don't know what fractional means

what is your plan?
ChatGPT said:

Alright, this is actually a very reasonable situation to be in ğŸ‘
Youâ€™ve built a real system, it works, Copilot gave you a FOPID that â€œkind of worksâ€, and now you want to understand + justify + compute a controller properly using MATLAB â€” without turning this into a PhD.

Iâ€™ll give you a clear, realistic plan, tailored to:

    your current knowledge level,

    your existing MATLAB script,

    and the fact that the plant is a computer fan (RPM control).

No math overload, no C# talk.
The short answer (big picture)

Plan:
We will design a fractional-order PI controller (FOPI) first, using your MATLAB script, validate it, and only then decide whether adding a fractional D term (FOPID) is actually necessary.

    For a fan RPM system:
    ğŸ”¹ FOPI is usually enough
    ğŸ”¹ FOPID is often overkill and harder to justify

Before the plan: ultra-brief intuition (important)
What P, I, D do (plain English)

    P (Proportional)
    â€œIf the RPM error is big â†’ react strongly.â€
    âœ” Fast response
    âŒ Leaves steady-state error

    I (Integral)
    â€œIf error exists for a long time â†’ eliminate it.â€
    âœ” Zero steady-state error
    âŒ Can cause overshoot / oscillation

    D (Derivative)
    â€œIf RPM is changing too fast â†’ slow down.â€
    âœ” Damping, stability
    âŒ Sensitive to noise

Why sometimes PI, sometimes PID?
System type	Typical controller
Slow, smooth (fan, motor speed)	PI
Fast, oscillatory	PID
Noisy measurements	Avoid D

ğŸ‘‰ Fan RPM â‰ˆ classic PI use-case
What â€œfractionalâ€ means (intuitively)

Normally:

    Integral = 1/s1/s

    Derivative = ss

Fractional control says:

    Integral = 1/sÎ»1/sÎ», where Î» is not 1

    Derivative = sÎ¼sÎ¼, where Î¼ is not 1

So instead of:

    â€œIntegrate fullyâ€

you get:

    â€œIntegrate partiallyâ€

Why thatâ€™s useful

    More tuning freedom

    Smoother response

    Less overshoot

    More robust to model errors

Think of it as a volume knob instead of an on/off switch.
Now: the actual plan ğŸ§­
Phase 1 â€” Lock the scope (what you will NOT do)

You will not:

    Identify a full fan model from physics

    Design an optimal controller

    Do fractional math by hand

    Implement fractional operators in C# (already done)

This is a control-lab-level project, not research.
Phase 2 â€” Decide the controller structure

We choose:
C(s)=Kp(1+Kisâˆ’Î»)
C(s)=Kpâ€‹(1+Kiâ€‹sâˆ’Î»)

Why?

    Matches your MATLAB script

    Easy to explain in a report

    Enough for RPM control

    Fractional part adds justification + novelty

â¡ï¸ This is a FOPI controller

We will not do FOPID unless tests clearly show itâ€™s needed.
Phase 3 â€” Adapt your MATLAB script (minimal changes)

Your script already does 90% of the job.

What it already does:
âœ” Uses sine test data
âœ” Extracts gain and phase
âœ” Chooses fractional order miu = Î»
âœ” Computes kp and ki
âœ” Builds a fractional PI controller

So the plan is:
Step 3.1 â€” Replace the plant data

    Use fan RPM response instead of lab data

    Either:

        sine modulation of PWM â†’ RPM

        or step response (simpler)

We can adapt the script to work with step data if needed.
Step 3.2 â€” Pick ONE design frequency

    Fan dynamics are slow â†’ low frequency

    Choose frequency where:

        fan reacts clearly

        noise is low

This replaces:

freq = 0.185;

Step 3.3 â€” Let the script compute:

    Î» (fractional order)

    KpKpâ€‹

    KiKiâ€‹

You already have this part:

miu = 1.09;
ki = ...
kp = ...

â¡ï¸ These become your final controller parameters
Phase 4 â€” Validate (MATLAB only)

You check:

    Step response

    Overshoot

    Settling time

    Steady-state error

If:

    steady-state error â‰ˆ 0 âœ”

    no wild oscillations âœ”

â¡ï¸ Stop. This is good engineering.
Phase 5 â€” Only if needed: extend to FOPID

If (and only if):

    response is too oscillatory

    or settling time is too long

Then we add:
+KdsÎ¼
+Kdâ€‹sÎ¼

This is:

    one extra parameter

    more tuning

    harder to justify in a report

For a fan, most projects never need this.
How youâ€™ll explain this in your project report

Youâ€™ll be able to say:

    â€œA fractional-order PI controller was chosen because the fan exhibits slow, first-order dynamics. The fractional integral term allows finer tuning of the steady-state error and transient response compared to a classical PI controller.â€

Thatâ€™s a solid, defensible statement.
Final checkpoint

If you want, next we can:

    Strip your MATLAB script down to the exact minimal version you need for a fan

    Decide PI vs FOPI vs PID based on one fan experiment

    Translate kp, ki, Î» cleanly into your C# FOPID structure

    Help you write the methodology section of the project

Just tell me what you want to tackle first.
You said:
i do not need to write a report, i just need to make something simple that works. Currently, my FOPID controller, given that Copilot made it correctly, works with kp = 0.005 and changes the PWM frequency once every 500ms. it seems to have a bit of overshoot, but it stabilizes.

however, as i said, it is not computed. so:
1. help me understand better, just the intuition, for P, I and D
2. help me understand better, again just the intuition, for fractional. i do not really understand this part
ChatGPT said:

Perfect â€” thanks for clarifying.
Then weâ€™ll forget reports, forget MATLAB math, forget formal design and focus on intuition that actually maps to what youâ€™re seeing with the fan.

Iâ€™ll keep this concrete and grounded in your exact situation:
PWM â†’ fan â†’ RPM â†’ overshoot â†’ settles.
1ï¸âƒ£ Intuition for P, I, D (fan RPM edition)

Think of this as how you twist the PWM knob based on RPM error.
P â€” Proportional

    â€œHow hard do I push when Iâ€™m wrong?â€

What it does

    Looks at current error:

    error = target_RPM âˆ’ current_RPM

    If error is big â†’ big PWM change

    If error is small â†’ small PWM change

What you see on a fan

    Increase kp â†’ fan reacts faster

    Too much kp â†’ overshoot (RPM goes past target)

Mental image

Youâ€™re driving and see youâ€™re below speed limit â†’ you press the gas proportional to how slow you are.
Why P alone is not enough

    When error becomes small, the push becomes tiny

    Fan may stabilize slightly below target RPM

â¡ï¸ P = fast reaction, but imperfect accuracy
I â€” Integral

    â€œHave I been wrong for a long time?â€

What it does

    Adds up error over time

    Even a small error, if it lasts long enough, gets corrected

What you see on a fan

    Eliminates steady-state error

    Fan reaches exact RPM target

The catch

    If error accumulates too much â†’ overshoot

    Fan feels â€œlazyâ€ to stop correcting

Mental image

You keep being 2 km/h under the speed limit for 30 seconds â†’ you slowly press more gas even though the error is small.

â¡ï¸ I = accuracy, but can cause overshoot
D â€” Derivative

    â€œHow fast am I approaching the target?â€

What it does

    Looks at rate of change of RPM

    If RPM is rising fast â†’ slow down early

What you see on a fan

    Reduces overshoot

    Makes the system feel â€œbrakedâ€ near target

The catch

    Sensitive to noise (RPM measurement jitter)

    Often unnecessary for slow systems like fans

Mental image

Youâ€™re about to reach the speed limit fast â†’ you lift your foot before hitting it.

â¡ï¸ D = damping / anticipation
Why your system works with small kp = 0.005

    Fan is slow

    PWM update every 500 ms (very slow control loop!)

    That alone acts like damping

    Overshoot is mild and settles

This is why even a guessed controller works ğŸ™‚
2ï¸âƒ£ Fractional control â€” intuition only (no math)

This is the confusing part, but itâ€™s actually simple conceptually.
Classical control (what you already know)

    Integral = â€œremember everything equallyâ€

    Derivative = â€œreact to instant change onlyâ€

These are extremes.
Fractional control says:

    â€œWhat if I want something in between?â€

Fractional Integral (Î»)
Normal integral

    Remembers error forever

    Old errors matter just as much as recent ones

Fractional integral

    Remembers recent past more

    Old errors fade away gradually

What this means for your fan

    Less integral windup

    Less overshoot

    Still removes steady-state error

Mental image

Instead of:

    â€œI remember every mistake foreverâ€

Itâ€™s:

    â€œI mostly care about what happened recentlyâ€

Fractional Derivative (Î¼)
Normal derivative

    Reacts only to instantaneous slope

    Very sensitive to noise

Fractional derivative

    Reacts to trend, not spikes

    Smoother damping

Mental image

Instead of:

    â€œOMG it changed right now!â€

Itâ€™s:

    â€œHmm, itâ€™s been speeding up latelyâ€¦â€

Why fractional helps fans specifically

Fans are:

    Slow

    Noisy (RPM measurement jitter)

    Have delays

Fractional control:

    Is more forgiving

    Gives smoother PWM changes

    Handles delay better

Thatâ€™s why your Copilot FOPID â€œjust worksâ€.
The two extra parameters you saw

In FOPID:
Parameter	Meaning
Î» (lambda)	How â€œstrongâ€ the memory of I is
Î¼ (mu)	How aggressive D is

Typical values:

    Î» â‰ˆ 0.7â€“1.2

    Î¼ â‰ˆ 0.5â€“1

You donâ€™t need to know the math â€” just know:

    They soften I and D.

Why you donâ€™t feel fractional control as different

Because:

    You update PWM every 500 ms

    Fan dynamics are slow

    Differences are subtle but stabilizing

Fractional control shines exactly in systems like this.
Final intuition summary (pin this)

    P â†’ â€œpush harder when wrongâ€

    I â†’ â€œfix long-term errorâ€

    D â†’ â€œslow down before overshootingâ€

    Fractional â†’ â€œdo all of the above, but less aggressively and more smoothlyâ€

If you want next:

    I can tell you exactly which terms you can safely remove

    Or explain why PI alone is probably enough

    Or help you tune Î» and Î¼ by feel, not math

Just tell me.
You said:
Why P alone is not enough

When error becomes small, the push becomes tiny

Fan may stabilize slightly below target RPM

â¡ï¸ P = fast reaction, but imperfect accuracy

why? in theory, i believe the rpm would get exponentially slower (it will look like the log curve?) to the target RPM? will it never reach it ?
ChatGPT said:

Great question â€” this is exactly the right thing to be confused about, and your intuition is almost right. The missing piece is what â€œsteady-stateâ€ really means in a real, physical system like a fan.

Letâ€™s clear this up cleanly.
Short answer (then weâ€™ll justify it)

    With P-only control, the RPM can approach the target asymptotically, but in a real fan it will settle at a value below the target.

Not because of math tricks â€” but because the fan needs a non-zero PWM to counter losses, and P-only control cannot generate that PWM once the error is zero.
Your intuition: â€œexponentially slower to the targetâ€

Youâ€™re thinking of something like this:

    Error â†’ smaller

    Control effort â†’ smaller

    RPM â†’ slowly creeps toward target

That is true for an ideal system.

But real fans are not ideal.
The key missing idea: equilibrium requires effort
A fan at constant RPM needs:

    Torque to overcome:

        friction

        air drag

        bearing losses

    That means non-zero PWM

Letâ€™s walk through what P-only does.
P-only control logic (simplified)

PWM = kp Ã— (target_RPM âˆ’ actual_RPM)

At the target RPM:

    error = 0

    PWM = 0

âŒ That means no torque
âŒ That means RPM must fall

So the system cannot stay at the target.
What actually happens

The fan settles at a point where:

kp Ã— error = PWM_needed_to_hold_RPM

Which implies:

error â‰  0

Thatâ€™s the steady-state error.
Visual intuition

Imagine pushing a box across the floor.

    P = how hard you push based on how far the box is from the target

    Friction resists motion

To keep the box moving:

    You must keep pushing

    If you stop pushing â†’ box stops

But P-only says:

    â€œIf distance = 0 â†’ push = 0â€

So the box stops before the target.
Why it looks exponential at first

At the beginning:

    Error is large

    PWM is large

    Fan accelerates quickly

As RPM rises:

    Error shrinks

    PWM shrinks

    Acceleration drops

This gives you:

    An exponential-looking rise

    Then a flat plateau below target

Why it never reaches the target (in practice)

Because reaching the target requires:

PWM > 0  at error = 0

But P-only canâ€™t do that.
What Integral fixes

Integral says:

    â€œIf error persists, even if itâ€™s small, keep increasing PWM.â€

So eventually:

    PWM matches losses

    Error goes to zero

    RPM locks exactly to target

Why your system almost reaches the target

You might say:

    â€œBut my fan almost hits it!â€

Thatâ€™s because:

    Very small error Ã— kp â‰ˆ required PWM

    Measurement noise masks the true error

    Discrete updates (500 ms) blur the math

But the offset is always there, even if tiny.
Mathematical intuition (no equations)

    P-only control finds a balance point

    That balance point is not the target

    Integral shifts the balance point to the target

Final mental model (this is the one to keep)

    P gets you close

    I gets you exact

    D keeps you civilized

And:

    Fractional I gets you exact, but gently

If you want next, I can:

    Show why P-only works perfectly in simulation but not in reality

    Explain why your 500 ms update acts like a hidden D term

    Explain why overshoot appears only when I is present

Just say the word.
You said:
understood, let's move on to I
ChatGPT said:

Nice â€” this is the right order to learn it.
Letâ€™s zoom in on I (Integral) and keep everything tied to your fan.
Integral control (I) â€” intuition that actually sticks
One-sentence idea

    I exists to generate the â€œconstant pushâ€ that P cannot.

Thatâ€™s it. Everything else is a consequence.
What I really does (no equations)

Integral means:

    â€œIf there is any error, keep adding to the control signal.â€

Even if the error is:

    small

    constant

    barely measurable

â€¦it keeps accumulating.
Why I is necessary for a fan

Recall:

    Fan needs constant PWM to hold RPM

    At target RPM:

        P gives 0 PWM

        Fan slows down

Integral fixes this by saying:

    â€œI remember that I had to push to get here.â€

So:

    PWM stays non-zero

    RPM stays at target

Step-by-step fan story (this is the key)
1ï¸âƒ£ Start below target RPM

    Error is large

    P pushes hard

    I starts accumulating

2ï¸âƒ£ RPM approaches target

    Error becomes small

    P contribution shrinks

    I contribution is already built up

3ï¸âƒ£ At target RPM

    Error â‰ˆ 0

    P â‰ˆ 0

    I still outputs PWM

That PWM exactly balances:

    friction

    air drag

    losses

â¡ï¸ Stable RPM with zero error
Why I causes overshoot

This part is crucial.
What I doesnâ€™t know

Integral does not know when to stop accumulating until the error changes sign.

So:

    Fan is accelerating

    Error is still positive

    I keeps increasing PWM

    RPM overshoots target

Only after overshoot:

    Error becomes negative

    I starts unwinding

Thatâ€™s why:

    I improves accuracy

    but hurts transient behavior

Mental image (very important)

Imagine filling a bucket with a slow leak:

    Error = water level below mark

    I = you keep pouring water

    Even when youâ€™re almost at the mark:

        youâ€™re still pouring

    Result: overflow (overshoot)

Why I alone is also bad

If you use only I:

    No immediate reaction

    Very slow response

    Huge overshoot

Thatâ€™s why PI exists:

    P â†’ reacts now

    I â†’ fixes long-term error

What happens when KI is too large

On your fan:

    PWM ramps too much

    Big overshoot

    Oscillation

    â€œHuntingâ€ around target RPM

This is integral windup.
Fractional I (preview, intuitive only)

Normal I:

    Remembers everything forever

Fractional I:

    Remembers recent past more

    Old errors slowly fade

So:

    Still removes steady-state error

    Overshoot is smaller

    Recovery is smoother

This is why fractional PI feels â€œnicerâ€.
Why your 500 ms update matters

Your loop:

    Integrates slowly

    Acts like a built-in limiter

    Prevents runaway integral

Thatâ€™s why:

    Even guessed KI values donâ€™t explode

    System still stabilizes

Takeaway (lock this in)

    P â†’ gets you moving

    I â†’ keeps you there

    Too much I â†’ overshoot

    Fractional I â†’ same goal, softer memory

Next logical step:
ğŸ‘‰ D (Derivative) â€” why it prevents overshoot without fixing steady-state error
or
ğŸ‘‰ Fractional I in practice â€” how Î» changes behavior by feel

Which one do you want next?
You said:
explain the intuition behind the math of adding the intergral. why is I memory? i know that the integral is something like area underneath a graph being added.. but i don't really undestand how you sample the exact area beneath a graph or if it's even true and how do you express it in terms of measurement unit?
ChatGPT said:

This is an excellent question â€” youâ€™re now asking about the why behind the math, not just the effect.
Iâ€™ll go slow, build intuition step by step, and keep it physical, not abstract calculus.
1ï¸âƒ£ Why â€œintegral = memoryâ€ is not just a metaphor

You already know:

    Integral â‰ˆ area under a curve

The key insight is what that area represents physically.

Letâ€™s define the signal being integrated:

error(t) = target_RPM âˆ’ actual_RPM

Now imagine you donâ€™t look at the error once, but you keep adding it up over time.

That accumulated sum is exactly what we call memory.
2ï¸âƒ£ Discrete-time view (this is how your C# code actually works)

Forget continuous math for a moment.

Your controller runs every 500 ms.

So what you really compute is something like:

I = I + error Ã— Î”t

Thatâ€™s it.

No calculus magic.

Each update:

    Take the current error

    Multiply by time step

    Add it to the stored value

That stored value is the integral.
3ï¸âƒ£ Why this equals â€œarea under the curveâ€

Imagine plotting error vs time:

    At each 500 ms:

        You add a rectangle:

            height = error

            width = Î”t

Stacking rectangles = approximating the area.

So yes:

    You are sampling the area

    You never need the â€œexactâ€ area

    Control systems work perfectly with this approximation

This is called numerical integration, and itâ€™s exactly whatâ€™s happening.
4ï¸âƒ£ Why this creates memory (the crucial leap)

Letâ€™s say:

    Error = +100 RPM for 10 seconds

Every cycle:

    You add +100 Ã— 0.5 to I

After 10 seconds:

    I is large

Now suppose:

    Error suddenly becomes 0

What happens to I?

â¡ï¸ Nothing. It stays large.

That means:

    The controller remembers the past error

    Even though the present error is zero

Thatâ€™s memory.
5ï¸âƒ£ Why memory is exactly what you need

Recall the fan problem:

    To maintain RPM:

        You need constant PWM

    But at target RPM:

        error = 0

        P gives PWM = 0

Integral says:

    â€œI remember that I needed PWM to get here.â€

So it keeps outputting PWM because the stored integral is non-zero.
6ï¸âƒ£ Units: this is the part most people never explain

Letâ€™s do it properly.
Error unit

RPM

Time unit

seconds

Integral of error

RPM Ã— seconds

Thatâ€™s weird at first â€” but stay with me.

Now multiply by KI:

KI Ã— (RPM Ã— s) = PWM

So:

KI has units: PWM / (RPM Ã— s)

Nothing unphysical is happening.

The integral stores:

    â€œHow much RPM error has existed for how long.â€

7ï¸âƒ£ Why integral ramps the output

If error is constant:

    Each step adds the same amount

    Integral grows linearly

Thatâ€™s why:

    PWM ramps up

    Instead of jumping instantly

This ramping is why integral is:

    Powerful

    Dangerous

8ï¸âƒ£ Why integral overshoots (math intuition)

Integral only stops growing when:

error = 0

But:

    Fan has inertia

    By the time error becomes zero

    PWM is already too large

So:

    RPM keeps rising

    Error becomes negative

    Integral slowly unwinds

Overshoot is not a bug â€” itâ€™s built into the math.
9ï¸âƒ£ Why this is NOT about â€œexact areaâ€

Important correction to your intuition:

âŒ The integral is not about measuring a precise geometric area
âœ… Itâ€™s about accumulating influence over time

Control theory borrowed the math language â€” but the meaning is physical.
ğŸ”Ÿ Final mental model (keep this)

    Each control loop:

        â€œHow wrong am I?â€

        â€œHow long have I been wrong?â€

    Add that to a memory register

    Use that memory to push harder

That memory is the integral.
Preview: fractional integral (why it softens memory)

Classical integral:

    â€œEvery past error matters equally.â€

Fractional integral:

    â€œRecent errors matter more than ancient ones.â€

So instead of:

I = I + error Ã— Î”t

Itâ€™s more like:

I = (slightly forget old stuff) + error Ã— Î”t

Same idea, gentler behavior.

If you want next, I can:

    Explain why derivative is â€œpredictionâ€ mathematically

    Show what fractional I changes in this exact accumulation

    Map this directly to your C# variables

Just say where to go next.
You said:
okay, now D?
ChatGPT said:

Alright! Letâ€™s tackle D â€“ the derivative part intuitively, and Iâ€™ll tie it to what you already know about P and I.
1. The intuition

The derivative looks at how fast the error is changing.

    If the error is growing quickly, the derivative pushes against that growth to prevent overshoot.

    If the error is decreasing quickly, the derivative may hold back the â€œpushâ€ a bit to avoid crashing past the target.

Think of it like predicting the future: it doesnâ€™t just care about how far you are from the target (P) or how long youâ€™ve been off (I), it cares about the speed at which youâ€™re approaching or leaving the target.
2. Intuition in terms of a fan

    P reacts to â€œyouâ€™re 100 RPM too low, spin faster!â€

    I reacts to â€œyouâ€™ve been too slow for 10 seconds, letâ€™s add more to compensateâ€

    D reacts to â€œRPM is climbing fast, slow down a little before overshooting.â€

So derivative reduces overshoot and smooths the response.
3. Intuition about the math

    Derivative = slope = change in error per unit of time: D=KDâ‹…ddt(error)D=KDâ€‹â‹…dtdâ€‹(error)

    Units: if error is RPM and time is seconds, then derivative is RPM per second.

    Multiplying by KDKDâ€‹ adjusts how strongly you react to that rate of change.

âœ… Summary

    P: reacts to current error

    I: reacts to accumulated error (memory)

    D: reacts to speed of change of error (prediction)

This is why PID controllers are powerful: they cover present, past, and future trend of the error.

If you want, I can now explain fractional order in a way that directly links to what you already understand about P, I, and D â€” itâ€™s simpler than it sounds. Do you want me to do that next?
You said:
explain a bit how these relate to the matlab script. i understand the intuition of all 3 now, so i think i could correlate to the script
ChatGPT said:

Perfect! Now that you have the intuition, letâ€™s connect it to your MATLAB script and see how it relates to P, I, D and fractional order:
1. Where P shows up

In your script:

kp = (1/M)*(1/sqrt(1+2*ki*wt^(-miu)*cos(pi*miu/2)+(ki^2)*wt^(-2*miu)));

    kp is the proportional gain.

    Itâ€™s basically the â€œhow hard we push for the current errorâ€ factor.

    In a regular PID, this is just the Kp youâ€™d tune manually.

2. Where I shows up

ki = (tan(pi-phm+process_phase)*(wt^miu))/(sin(pi*miu/2)-(tan(pi-phm+process_phase)*cos(pi*miu/2)));

    ki is the integral gain, controlling the memory effect.

    Later, itâ€™s combined with kp in:

reg = minreal(kp + kp*ki*tf(1,[1,0])*s_alfa1);

    tf(1,[1,0]) is the 1/s term, the Laplace transform representation of an integral.

    So kp*ki*1/s is basically the I-term.

3. Where fractional comes in

alfa1 = 1-miu;
alfa = miu;
s_alfa1 = ora_foc_RdK(alfa1,2,0.01,100);

    Here, instead of 1/s (normal integral) or s (normal derivative), you have s^(-alfa1) or s^alfa.

    Thatâ€™s fractional calculus: the exponent can be non-integer.

    Fractional order smoothly interpolates between P, I, D behavior.

        If Î± = 1 â†’ normal integral

        If Î± = 0.5 â†’ â€œhalf integralâ€, slower memory effect

        Same for derivative.

4. Putting it together

The final controller:

reg = minreal(kp + kp*ki*tf(1,[1,0])*s_alfa1);

    kp â†’ proportional

    kp*ki*1/s^Î±1 â†’ fractional integral (I)

    There is a commented part that could add fractional derivative if you want:

% reg = minreal(kp+kp*ki/s_alfa1);

    And later you can discretize it to implement it on your fan.

âœ… Summary

    P = kp

    I = ki combined with 1/s^Î±1

    D (optional fractional) = could be added as s^Î± term

    Fractional order = Î± and 1-Î± (miu) are the tweaks that let you â€œtune the memory and prediction smoothlyâ€ instead of being all-or-nothing.

If you want, the next step is how to modify this script to compute a simple FOPI for your fan, using your known frequency response, without worrying too much about advanced derivations. Thatâ€™s usually enough to get it working in C#.

Do you want me to do that next?
You said:
oh wait, right, what is the fractional part? i forgot about that. let's go back to the intuition. i don't understand:
- what is it
- why would you add something else besides P, I and D
- if this fractional thing only makes sense in PI ctrl
ChatGPT said:

Perfect, letâ€™s slow down and focus on fractional order, in terms you can intuitively grasp.
1. What fractional order is

    In regular PID:

        P reacts to current error â†’ proportional

        I integrates error â†’ memory

        D differentiates error â†’ prediction

    Fractional order PID (FOPID / FOPI / FOPD) allows the integral and derivative exponents to be non-integer.

Think of it like this:

    Normal integral: 1/s â†’ â€œfull memoryâ€ of error

    Fractional integral: 1/s^Î± with 0 < Î± < 1 â†’ â€œpartial memoryâ€

    Normal derivative: s â†’ â€œfull reaction to speed of changeâ€

    Fractional derivative: s^Î² with 0 < Î² < 1 â†’ â€œpartial predictionâ€

So fractional order lets you interpolate between P, I, and D behavior instead of being all-or-nothing.
2. Why would you add it besides P, I, D?

    Normal PID is limited: P+I+D can sometimes overshoot, oscillate, or be too slow, especially for systems with â€œweirdâ€ dynamics (like a fan with friction, delay, or nonlinearities).

    Fractional terms give extra tuning flexibility:

        You can make the integral act slower or faster than normal.

        You can make the derivative act less aggressive or smoother.

    Intuition: itâ€™s like saying â€œI donâ€™t want full memory, I want somewhere between memory and instant reactionâ€ or â€œI donâ€™t want full derivative, just a partial trend prediction.â€

3. Does it only make sense for PI?

    No, it can be applied to I and D in any combination:

        FOPI â†’ fractional integral, no derivative

        FOPD â†’ fractional derivative, no integral

        FOPID â†’ fractional integral + fractional derivative

    P usually stays normal (integer order), because fractional P isnâ€™t meaningfulâ€”P is already â€œinstant push proportional to error.â€

âœ… Intuitive analogy

    Regular integral: â€œremember everything equally from the past.â€

    Fractional integral: â€œremember more recent past more strongly, distant past less strongly.â€

    Regular derivative: â€œreact exactly to speed.â€

    Fractional derivative: â€œreact partially to speed, smoother.â€

Itâ€™s basically a way to have finer control over how memory and prediction work.

If you want, I can now explain how your MATLAB script is actually computing a fractional integral for the PI controller, in the simplest way possible. That will directly connect the intuition with the code.

Do you want me to do that next?
You said:
why wouldn't I or D be integral without fractional order stuff? when i have seen a PID impmlemented in the past, i could tune the P, I and D to be anywhere between 0 and 1, and i don;t think it was a fractional order
ChatGPT said:

Ah, I see exactly whatâ€™s confusingâ€”youâ€™re thinking about the tuning values (gains) vs the â€œorderâ€ of the operation. Let me clarify:
1. Tuning a normal PID

    When you set Kp, Ki, or Kd between 0 and 1, you are just scaling the effect of that term:

        Kp = 0.5 â†’ proportional push is half as strong

        Ki = 0.2 â†’ integral memory effect is weaker

        Kd = 0.1 â†’ derivative reaction is smaller

    This does not change the type of operation: the integral is still a full integral, the derivative is still a full derivative.

        Mathematically: integral is still 1/s, derivative is still s in Laplace domain.

2. Fractional order PID

    Fractional order PID changes the operation itself, not just the scale:

        Fractional integral: 1/s^Î± with Î± â‰  1 â†’ â€œpartial memoryâ€

        Fractional derivative: s^Î² with Î² â‰  1 â†’ â€œpartial predictionâ€

    The difference is subtle but important:

        Normal PID: only integer powers (s or 1/s)

        Fractional PID: non-integer powers (s^0.5 or 1/s^0.7)

    Tuning Ki in normal PID = change strength of memory

    Changing Î± in FOPID = change how memory accumulates over time, not just its strength

3. Analogy

    Normal PID: â€œI remember everything equally (integral), I react exactly to speed (derivative)â€

    Fractional PID: â€œI remember more recent things more, distant past less (integral), I react partially to speed (derivative)â€

âœ… Key point:
You can always make a normal PID work by tuning gains, but fractional PID gives more flexibility in the shape of response, especially for systems with slow dynamics, delays, or oscillations.

If you want, the next step could be linking this directly to the MATLAB script so you see exactly where the fractional integral (s^-Î±) comes in, and how you would compute a FOPI for your fan. Thatâ€™s the part that will make the script actually useful for your project.

Do you want me to go there next?
You said:
basically, 1/s = integral in laplace domain, but 1/s^0.5 is not an integral anymore? how would you reflect this change in time domain? 
ChatGPT said:

Exactly, youâ€™re on the right track â€” letâ€™s carefully break this down.
1. 1/s in Laplace â†’ normal integral

    In Laplace domain:

I(s)=1sE(s)
I(s)=s1â€‹E(s)

    In time domain:

i(t)=âˆ«0te(Ï„)â€‰dÏ„
i(t)=âˆ«0tâ€‹e(Ï„)dÏ„

    This is full memory, every past error counts equally.

2. 1/s^Î± in Laplace â†’ fractional integral

    If Î± = 0.5,

I(s)=1s0.5E(s)
I(s)=s0.51â€‹E(s)

    This does not correspond to the usual integral anymore. Itâ€™s a fractional integral.

    Time-domain equivalent is more complicated â€” called the Riemannâ€“Liouville fractional integral:

iÎ±(t)=1Î“(Î±)âˆ«0te(Ï„)(tâˆ’Ï„)1âˆ’Î±dÏ„
iÎ±â€‹(t)=Î“(Î±)1â€‹âˆ«0tâ€‹(tâˆ’Ï„)1âˆ’Î±e(Ï„)â€‹dÏ„

Where Î“(Î±) is the gamma function (generalizes factorial).
3. Intuition in time domain

    Normal integral (Î±=1): all past error counts equally â†’ sum/area under curve.

    Fractional integral (0<Î±<1): recent errors count more, distant past counts less â†’ â€œweighted memoryâ€ with a decaying influence over time.

Think of it like forgetting slowly: the further in the past the error, the less it contributes, but it still contributes a little.

    If Î± < 1, memory is partial, smoother, less aggressive than full integral.

    If Î± > 1 (rare), memory effect grows faster than normal integral (almost like â€œsuper integralâ€).

4. Why this matters

    On your fan: a normal integral could accumulate too aggressively, causing overshoot or oscillations.

    Fractional integral lets you tune how memory accumulates, giving smoother control.

If you want, I can now show exactly how your MATLAB script implements the fractional integral, in terms you could plug into your fan controller. This will connect everything youâ€™ve learned to practical use.

Do you want me to do that?
You said:
this seems like advanced math, but i understood that:
- using a fractional order, you change the argument of the integral (in time domain)
- the effect is a more optimized "memory" for control, in the sense that recent memory is more important
ChatGPT said:

Exactly! Thatâ€™s the right intuitionâ€”you donâ€™t need to worry about the gamma functions or complicated math if your goal is just practical control.

    Fractional order changes the â€œshapeâ€ of memory, not just its strength.

    Recent errors matter more than old ones, unlike a normal integral that treats all past errors equally.

    This gives you smoother, better-tuned control with less overshoot or oscillation.

Basically, itâ€™s like having a smarter memory knob on your controller.

Next, we can see how your MATLAB script actually computes this fractional integral for the FOPI controller so you can use it with your fan. That will make it concrete. Do you want me to explain that?
You said:
before this, how can i save this chat? i am not logged in
ChatGPT said:

Since youâ€™re not logged in, you donâ€™t have automatic chat history saved. Here are a few simple ways to keep a copy:

    Copy and paste

        Select all the text in this chat and paste it into a text editor (Notepad, Word, or anything you like).

    Print to PDF

        Press Ctrl+P (or Cmd+P on Mac) â†’ choose â€œSave as PDFâ€ as the printer â†’ save the chat as a PDF file.

    Screenshots

        Take screenshots of the conversation if you just want a visual record.

Copy-paste or PDF is usually easiest if you want to refer back later while working in MATLAB or C#.

Do you want me to continue with how the MATLAB script computes the fractional integral next?
You said:
if i log in, will this chat be saved?
ChatGPT said:

Yes â€” if you log in, your chats can be saved automatically in your account, so you can return to them later.

A few things to know:

    Saved chats are linked to your account, not your device.

    You can name, search, or continue a saved chat.

    If you donâ€™t log in, this chat will not be saved when you close the page.

So logging in is the easiest way to keep this conversation for future reference.

Do you want me to continue now with the MATLAB script explanation?


ChatGPT can make mistakes. Check important info. See Cookie Preferences.
